// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OHLCVSOAOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OHLCVSOA<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OHLCVSOA<'a> {
  type Inner = OHLCVSOA<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OHLCVSOA<'a> {
  pub const VT_TIMESTAMPS: flatbuffers::VOffsetT = 4;
  pub const VT_OPENS: flatbuffers::VOffsetT = 6;
  pub const VT_HIGHS: flatbuffers::VOffsetT = 8;
  pub const VT_LOWS: flatbuffers::VOffsetT = 10;
  pub const VT_CLOSES: flatbuffers::VOffsetT = 12;
  pub const VT_VOLUMES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OHLCVSOA { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OHLCVSOAArgs<'args>
  ) -> flatbuffers::WIPOffset<OHLCVSOA<'bldr>> {
    let mut builder = OHLCVSOABuilder::new(_fbb);
    if let Some(x) = args.volumes { builder.add_volumes(x); }
    if let Some(x) = args.closes { builder.add_closes(x); }
    if let Some(x) = args.lows { builder.add_lows(x); }
    if let Some(x) = args.highs { builder.add_highs(x); }
    if let Some(x) = args.opens { builder.add_opens(x); }
    if let Some(x) = args.timestamps { builder.add_timestamps(x); }
    builder.finish()
  }


  #[inline]
  pub fn timestamps(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(OHLCVSOA::VT_TIMESTAMPS, None)}
  }
  #[inline]
  pub fn opens(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(OHLCVSOA::VT_OPENS, None)}
  }
  #[inline]
  pub fn highs(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(OHLCVSOA::VT_HIGHS, None)}
  }
  #[inline]
  pub fn lows(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(OHLCVSOA::VT_LOWS, None)}
  }
  #[inline]
  pub fn closes(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(OHLCVSOA::VT_CLOSES, None)}
  }
  #[inline]
  pub fn volumes(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(OHLCVSOA::VT_VOLUMES, None)}
  }
}

impl flatbuffers::Verifiable for OHLCVSOA<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("timestamps", Self::VT_TIMESTAMPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("opens", Self::VT_OPENS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("highs", Self::VT_HIGHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("lows", Self::VT_LOWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("closes", Self::VT_CLOSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("volumes", Self::VT_VOLUMES, false)?
     .finish();
    Ok(())
  }
}
pub struct OHLCVSOAArgs<'a> {
    pub timestamps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub opens: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub highs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub lows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub closes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub volumes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for OHLCVSOAArgs<'a> {
  #[inline]
  fn default() -> Self {
    OHLCVSOAArgs {
      timestamps: None,
      opens: None,
      highs: None,
      lows: None,
      closes: None,
      volumes: None,
    }
  }
}

pub struct OHLCVSOABuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OHLCVSOABuilder<'a, 'b, A> {
  #[inline]
  pub fn add_timestamps(&mut self, timestamps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_TIMESTAMPS, timestamps);
  }
  #[inline]
  pub fn add_opens(&mut self, opens: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_OPENS, opens);
  }
  #[inline]
  pub fn add_highs(&mut self, highs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_HIGHS, highs);
  }
  #[inline]
  pub fn add_lows(&mut self, lows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_LOWS, lows);
  }
  #[inline]
  pub fn add_closes(&mut self, closes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_CLOSES, closes);
  }
  #[inline]
  pub fn add_volumes(&mut self, volumes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OHLCVSOA::VT_VOLUMES, volumes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OHLCVSOABuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OHLCVSOABuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OHLCVSOA<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OHLCVSOA<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OHLCVSOA");
      ds.field("timestamps", &self.timestamps());
      ds.field("opens", &self.opens());
      ds.field("highs", &self.highs());
      ds.field("lows", &self.lows());
      ds.field("closes", &self.closes());
      ds.field("volumes", &self.volumes());
      ds.finish()
  }
}
pub enum OHLCVListSOAOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OHLCVListSOA<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OHLCVListSOA<'a> {
  type Inner = OHLCVListSOA<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OHLCVListSOA<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OHLCVListSOA { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OHLCVListSOAArgs<'args>
  ) -> flatbuffers::WIPOffset<OHLCVListSOA<'bldr>> {
    let mut builder = OHLCVListSOABuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<OHLCVSOA<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OHLCVSOA>>(OHLCVListSOA::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for OHLCVListSOA<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<OHLCVSOA>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct OHLCVListSOAArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<OHLCVSOA<'a>>>,
}
impl<'a> Default for OHLCVListSOAArgs<'a> {
  #[inline]
  fn default() -> Self {
    OHLCVListSOAArgs {
      data: None,
    }
  }
}

pub struct OHLCVListSOABuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OHLCVListSOABuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<OHLCVSOA<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OHLCVSOA>>(OHLCVListSOA::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OHLCVListSOABuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OHLCVListSOABuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OHLCVListSOA<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OHLCVListSOA<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OHLCVListSOA");
      ds.field("data", &self.data());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OHLCVListSOA`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ohlcvlist_soa_unchecked`.
pub fn root_as_ohlcvlist_soa(buf: &[u8]) -> Result<OHLCVListSOA, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OHLCVListSOA>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OHLCVListSOA` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ohlcvlist_soa_unchecked`.
pub fn size_prefixed_root_as_ohlcvlist_soa(buf: &[u8]) -> Result<OHLCVListSOA, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OHLCVListSOA>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OHLCVListSOA` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ohlcvlist_soa_unchecked`.
pub fn root_as_ohlcvlist_soa_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OHLCVListSOA<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OHLCVListSOA<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OHLCVListSOA` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ohlcvlist_soa_unchecked`.
pub fn size_prefixed_root_as_ohlcvlist_soa_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OHLCVListSOA<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OHLCVListSOA<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OHLCVListSOA and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OHLCVListSOA`.
pub unsafe fn root_as_ohlcvlist_soa_unchecked(buf: &[u8]) -> OHLCVListSOA {
  flatbuffers::root_unchecked::<OHLCVListSOA>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OHLCVListSOA and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OHLCVListSOA`.
pub unsafe fn size_prefixed_root_as_ohlcvlist_soa_unchecked(buf: &[u8]) -> OHLCVListSOA {
  flatbuffers::size_prefixed_root_unchecked::<OHLCVListSOA>(buf)
}
pub const OHLCVLIST_SOA_EXTENSION: &str = "bin";

#[inline]
pub fn finish_ohlcvlist_soa_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OHLCVListSOA<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_ohlcvlist_soa_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OHLCVListSOA<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
